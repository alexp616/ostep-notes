\chapter{File System Implementation}

This chapter covers a simplified version of a typical UNIX file system. It will be purely software, with no hardware support like seen in CPU and memory virtualization.

\section{The Way To Think \& Overall Organization}

A file system can be described by its data structures and access methods.

The disk is divided into uniformly-sized blocks. Blocks are reserved for:

\begin{itemize}
    \item User data, where the user's files go 
    \item An \textbf{inode table}, which stores metadata in \textbf{inodes}, which stores which blocks a file is stored in, its size, access rights, modify time, reference count, etc.
    \item The inode and data \textbf{bitmaps}, which have each bit indicate whether the corresponding object/block is free or in use.
    \item One \textbf{superblock}, which contains information about the file system, like how many inodes and data blocks are in the file system, and where they begin.
\end{itemize}

\section{File Organization: The Inode}

Inode is short for index node, because nodes were originally in an array which was indexed into. It holds metadata for a given file. They are identified by their \textbf{i-number}.

To read an inode, the file system has to calculate the byte address of the inode, access the corresponding block, then read the inode from the correct location.

The inode holds an array of disk pointers, which denote which blocks a file is stored in. Since this array can't get too big, a \textbf{multi-level index} data structure is needed. Like a tree, a leaf pointer points to a disk block with actual file data in it, and other node pointers point to disk blocks with pointers to other nodes.

Most files are small, meaning the array of pointers can directly point to occupied blocks.

\section{Directory Organization \& Free Space Management}

Directories contain a list of name and inode number pairs. In disk, an entry stores the inode number, bytes allocated for the name, how long the name actually is, and the name of the file.

Every directory also contains two extra entries \code{.} and \code{..}, corresponding to themselves and their parents.

Directories themselves are special files with their own inode.

A file system has to track which inodes and data blocks are free. This \textbf{free space management} requires a lot of considerations, like a file system can prefer to allocate a contiguous sequence of blocks over a fragmented one to improve performance.

\section{Access Paths: Reading and Writing}

To traverse a pathname, the file system starts at the root, which has a constant inode number. It scans through the blocks for a pointer to the next directory in the path, and jumps to it. It recursively continues until it finds the requested resource.

The amount of I/O generated by an open is proportional to the length of the pathname.

To write to a file, the file system needs to read the inode bitmap to find a free inode, write to it to mark it as allocated, write to the inode, write to the data of the directory to link the name of the file and its inode, and read and write the directory's inode.

\section{Caching and Buffering}

File systems commonly use memory to cache important blocks. This is called a \textbf{partitioning} of memory. Modern systems employ \textbf{dynamic partitioning} by integrating virtual memory pages and file system pages into a \textbf{unified page cache}.

Read I/O can be avoided with a large enough cache, but write traffic has to go to disk to be persistent. \textbf{Write buffering} is the implementation of speeding up writes by batching them whenever the buffer is full.

If the OS decides when writes will happen with write buffering, it will be able to schedule the writes, and even avoid small, temporary writes entirely.

Databases, which require persistence integrity, don't employ write buffering because of the possibly of losing data. Instead, they use \textbf{direct I/O} interfaces, or straight to the \textbf{raw disk} interface, avoiding the file system altogether.

\section{Summary}

